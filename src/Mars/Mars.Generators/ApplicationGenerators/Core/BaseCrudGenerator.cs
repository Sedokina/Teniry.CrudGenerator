using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Mars.Generators.ApplicationGenerators.Configurations;
using Mars.Generators.ApplicationGenerators.Configurations.Operations;
using Mars.Generators.ApplicationGenerators.Configurations.Operations.BuiltConfigurations;
using Mars.Generators.ApplicationGenerators.Core.DbContextCore;
using Mars.Generators.ApplicationGenerators.Core.EntitySchemaCore;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using Scriban;
using Scriban.Runtime;

namespace Mars.Generators.ApplicationGenerators.Core;

internal abstract class BaseGenerator
{
    protected readonly string AutogeneratedFileText;
    protected readonly bool NullableEnable;
    protected readonly GeneratorExecutionContext Context;

    protected BaseGenerator(GeneratorExecutionContext context, string autogeneratedFileText, bool nullableEnable)
    {
        AutogeneratedFileText = autogeneratedFileText;
        NullableEnable = nullableEnable;
        Context = context;
    }

    public abstract void RunGenerator();

    protected virtual void WriteFile(string templatePath, object model, string className)
    {
        var template = ReadTemplate(templatePath);

        var sb = new StringBuilder();
        sb.AppendLine(AutogeneratedFileText);
        if (NullableEnable)
        {
            sb.AppendLine("#nullable enable");
        }

        sb.AppendLine(template.Render(model));

        var sourceCode = sb.ToString().Trim();
        var result = CSharpSyntaxTree.ParseText(SourceText.From(sourceCode, Encoding.UTF8))
            .GetRoot()
            .NormalizeWhitespace()
            .SyntaxTree
            .GetText();

        Context.AddSource($"{className}.g.cs", result);
    }

    internal Template ReadTemplate(string templatePath)
    {
        return Template.Parse(GetEmbeddedResource(templatePath, GetType().Assembly));
    }

    private static string GetEmbeddedResource(string path, Assembly assembly)
    {
        using var stream = assembly.GetManifestResourceStream(path);
        using var streamReader = new StreamReader(stream ?? throw new InvalidOperationException());
        return streamReader.ReadToEnd();
    }
}

internal abstract class BaseCrudGenerator<TConfiguration> : BaseGenerator
    where TConfiguration : CqrsOperationWithoutReturnValueGeneratorConfiguration
{
    protected readonly CrudGeneratorScheme<TConfiguration> Scheme;
    protected readonly EntityScheme EntityScheme;
    protected readonly string BusinessLogicNamespace;
    public string EndpointNamespace { get; set; }
    public EndpointMap? EndpointMap { get; set; }

    protected BaseCrudGenerator(
        GeneratorExecutionContext context,
        CrudGeneratorScheme<TConfiguration> scheme)
        : base(context,
            scheme.Configuration.GlobalConfiguration.AutogeneratedFileText,
            scheme.Configuration.GlobalConfiguration.NullableEnable)
    {
        Scheme = scheme;
        EntityScheme = scheme.EntityScheme;
        BusinessLogicNamespace = scheme.Configuration.OperationsSharedConfiguration.BusinessLogicNamespaceBasePath
            .GetNamespacePath(
                EntityScheme.EntityName,
                Scheme.EntityScheme.ContainingAssembly,
                scheme.Configuration.OperationsSharedConfiguration.FeatureNameConfigurationBuilder,
                scheme.Configuration.FunctionName);
        EndpointNamespace = scheme.Configuration.OperationsSharedConfiguration.EndpointsNamespaceBasePath
            .GetNamespacePath(
                EntityScheme.EntityName,
                Scheme.EntityScheme.ContainingAssembly);
    }

    protected override void WriteFile(string templatePath, object model, string className)
    {
        var template = ReadTemplate(templatePath);

        var baseProps = new ScriptObject();
        var usingNamespaces = new[] { Scheme.DbContextScheme.DbContextNamespace, EntityScheme.EntityNamespace }
            .Distinct()
            .Select(x => $"using {x};");
        baseProps.Import(new
        {
            EntityName = EntityScheme.EntityName.ToString(),
            PluralEntityName = EntityScheme.EntityName.PluralName,
            EntityNamespace = EntityScheme.EntityNamespace,
            BusinessLogicNamespace = BusinessLogicNamespace,
            EndpointNamespace = EndpointNamespace,
            EntityTitle = EntityScheme.EntityTitle.ToString(),
            PluralEntityTitle = EntityScheme.EntityTitle.PluralTitle,
            DbContextName = Scheme.DbContextScheme.DbContextName,
            UsingNamespaces = string.Join("\n", usingNamespaces)
        });

        var customProps = new ScriptObject();
        customProps.Import(model);

        var context = new TemplateContext();
        context.PushGlobal(baseProps);
        context.PushGlobal(customProps);

        var sb = new StringBuilder();
        sb.AppendLine(AutogeneratedFileText);
        if (Scheme.Configuration.GlobalConfiguration.NullableEnable)
        {
            sb.AppendLine("#nullable enable");
        }

        sb.AppendLine(template.Render(context));

        var sourceCode = sb.ToString().Trim();

        var result = CSharpSyntaxTree.ParseText(SourceText.From(sourceCode, Encoding.UTF8))
            .GetRoot()
            .NormalizeWhitespace()
            .SyntaxTree
            .GetText();

        Context.AddSource($"{className}.g.cs", result);
    }
}

public class EndpointMap
{
    public string EntityName { get; set; }
    public string EndpointNamespace { get; set; }
    public string HttpMethod { get; }
    public string EndpointRoute { get; set; }
    public string FunctionCall { get; set; }

    public EndpointMap(string entityName, string endpointNamespace, string httpMethod, string endpointRoute,
        string functionCall)
    {
        EntityName = entityName;
        EndpointNamespace = endpointNamespace;
        HttpMethod = httpMethod;
        EndpointRoute = endpointRoute;
        FunctionCall = functionCall;
    }
}